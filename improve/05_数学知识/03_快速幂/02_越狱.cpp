// 监狱有连续编号为 1
//  到 n
//  的 n
//  个房间，每个房间关押一个犯人。

// 有 m
//  种宗教，每个犯人可能信仰其中一种。

// 不存在没有信仰的犯人。

// 如果相邻房间的犯人信仰的宗教相同，就可能发生越狱。

// 求有多少种状态可能发生越狱。

// 输入格式
// 共一行，包含两个整数 m
//  和 n
// 。

// 输出格式
// 可能越狱的状态数，对 100003
//  取余。

// 数据范围
// 1≤m≤108
// ,
// 1≤n≤1012
// 输入样例：
// 2 3
// 输出样例：
// 6
// 样例解释
// 所有可能的 6
//  种状态为：(000)(001)(011)(100)(110)(111)
// 。

/*
一共有n^m种方案，会越狱的方案数是：第一个人随机，第二个人不能和第一个人一样，有m-1种，第三个人不能和第二个人一样，也是m-1种，因此越狱的方案数为
n^m - m * (n - 1)^(m - 1)
*/
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const int mod = 100003;

LL qmi(LL a, LL b){
    LL res = 1;
    while(b){
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

int main(){
    int m;
    LL n;
    cin >> m >> n;
    cout << ((qmi(m, n) - (LL)m * qmi(m - 1, n - 1)) % mod + mod) % mod << endl; 
    
    return 0;
}