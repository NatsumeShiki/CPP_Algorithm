// 达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。

// 翰翰的家里有一辆飞行车。

// 有一天飞行车的电路板突然出现了故障，导致无法启动。

// 电路板的整体结构是一个 R
//  行 C
//  列的网格（R,C≤500
// ），如下图所示。

// 电路.png

// 每个格点都是电线的接点，每个格子都包含一个电子元件。

// 电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。

// 在旋转之后，它就可以连接另一条对角线的两个接点。

// 电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。

// 达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。

// 她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。

// 不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。

// 注意：只能走斜向的线段，水平和竖直线段不能走。

// 输入格式
// 输入文件包含多组测试数据。

// 第一行包含一个整数 T
// ，表示测试数据的数目。

// 对于每组测试数据，第一行包含正整数 R
//  和 C
// ，表示电路板的行数和列数。

// 之后 R
//  行，每行 C
//  个字符，字符是"/"和"\"中的一个，表示标准件的方向。

// 输出格式
// 对于每组测试数据，在单独的一行输出一个正整数，表示所需的最小旋转次数。

// 如果无论怎样都不能使得电源和发动机之间连通，输出 NO SOLUTION。

// 数据范围
// 1≤R,C≤500
// ,
// 1≤T≤5
// 输入样例：
// 1
// 3 5
// \\/\\
// \\///
// /\\\\
// 输出样例：
// 1
// 样例解释
// 样例的输入对应于题目描述中的情况。

// 只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。

// 电路2.png

// 难度：简单
// 时/空限制：1s / 64MB
// 总通过数：10677
// 总尝试数：23185
// 来源：《算法竞赛进阶指南》,BalticOI 2011
// 算法标签

#include<iostream>
#include<cstring>
#include<algorithm>
#include<deque>
#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;
const int N = 510;

int n, m;
char g[N][N];
int dist[N][N];
bool st[N][N]; 

int bfs(){
    deque<PII> q; // 双端队列
    memset(st, 0, sizeof st); // 多组测试数据，所以要清空
    memset(dist, 0x3f, sizeof dist);
    
    char cs[5] = "\\/\\/"; // 记录左上、右上、右下、左下四个方向权值为0时应该是 / 还是 \, 注意 \ 需要转义，所以一个 \ 要写成 \\ 
    int dx[4] = {-1, -1, 1, 1}, dy[4] = {-1, 1, 1, -1}; // 记录四个方向上的坐标位移差
    int ix[4] = {-1, -1, 0, 0}, iy[4] = {-1, 0, 0, -1}; // 记录 / \ 符号在坐标系中对应的位置
    
    dist[0][0] = 0;
    q.push_back({0, 0});
    
    while(q.size()){
        PII t = q.front();
        q.pop_front();
        
        int x = t.x, y = t.y;
        if(x == n && y == m) return dist[x][y]; 
        
        if(st[x][y]) continue; // 类似 dijkstra 算法，当st[x][y]为true的时候，表示该点已经被遍历过了
        st[x][y] = true;
        
        for(int i = 0; i < 4; i++){
            int a = x + dx[i], b = y + dy[i]; // a b 是经过位移得到的坐标
            if(a < 0 || a > n || b < 0 || b > m) continue; // 超过范围就conitnue，注意这里是 > n > m，因为长度n和m对应右下角的点的坐标
            int ga = x + ix[i], gb = y + iy[i]; // 记录位移后的坐标对应g数组中的符号的坐标
            int w = g[ga][gb] != cs[i]; // 如果该坐标与cs中不一样，就说明需要旋转，权值为1，否则权值为0
            int d = dist[x][y] + w; // 计算从 (x, y) 点到 (a, b) 点的距离
            if(d < dist[a][b]){ // 如果该距离比他记录中的要小
                dist[a][b] = d; // 更新距离
                if(!w) q.push_front({a, b}); // 如果权值为0，则放在双端队列的头部
                else q.push_back({a, b}); // 否则放在尾部
            }
        }
    }

    return -1; // 这一步不可能执行，因为一定有解
}


int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        scanf("%d%d", &n, &m);
        for(int i = 0; i < n; i++) scanf("%s", g[i]);
        
        if(n + m & 1) puts("NO SOLUTION"); // 因为只能移动对角线，横纵坐标同时 + - 1，坐标从(0,0)开始，也就是说横纵坐标坐标和都是偶数，因此如果终点的横纵坐标和是奇数，那么一定无法到达
        else printf("%d\n", bfs());
    }
    
    return 0;
}