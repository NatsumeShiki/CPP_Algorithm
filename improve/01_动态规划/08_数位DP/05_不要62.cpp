// 杭州人称那些傻乎乎粘嗒嗒的人为 62
// （音：laoer）。

// 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。

// 不吉利的数字为所有含有 4
//  或 62
//  的号码。例如：62315,73418,88914
//  都属于不吉利号码。但是，61152
//  虽然含有 6
//  和 2
// ，但不是 连号，所以不属于不吉利数字之列。

// 你的任务是，对于每次给出的一个牌照号区间 [n,m]
// ，推断出交管局今后又要实际上给多少辆新的士车上牌照了。

// 输入格式
// 输入包含多组测试数据，每组数据占一行。

// 每组数据包含一个整数对 n
//  和 m
// 。

// 当输入一行为“0 0”时，表示输入结束。

// 输出格式
// 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。

// 数据范围
// 1≤n≤m≤109
// 输入样例：
// 1 100
// 0 0
// 输出样例：
// 80

/*
动态规划
  状态表示f[i, j]
    集合：一共有i位，最高位是j的合法方案
    属性：Count
  状态计算
    枚举第i-1位选择什么数，0-9，如果符合条件就加上
    for(int j = 0; j <= 9; j++)
      for(int k = 0; k <= 9; k++)
        if(j != 4 && k != 4 && !(j == 6 && k == 2))
          f[i][j] += f[i - 1][k]
*/
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 11;
int f[N][10];

void init(){
    for(int i = 0; i <= 9; i++)
        if(i != 4) // 只有一位，让它不等于4
            f[1][i]++;
            
    for(int i = 2; i < N; i++) // 一共有i位
        for(int j = 0; j <= 9; j++) // 枚举第i位
            for(int k = 0; k <= 9; k++) // 枚举第i-1位
                if(j != 4 && k != 4 && !(j == 6 && k == 2)) // 如果满足题目要求
                    f[i][j] += f[i - 1][k]; // 就把方案累加上
}

int dp(int n){
    if(!n) return 1; // 0也是一种方案
    
    vector<int> nums;
    while(n) nums.push_back(n % 10), n /= 10;
    
    int res = 0, last = 0; // last记录的是上一个是什么数，只要不让他是6或者4即可
    for(int i = nums.size() - 1; i >= 0; i--){
        int x = nums[i];
        
        for(int j = 0; j < x; j++) // 左分支，枚举第i位
            if(j != 4 && !(last == 6 && j == 2)) // 如果满足要求，这里不需要last != 4，因为第一次是肯定不成立的，而后面如果有x等于4，会在下面的判断中break
                res += f[i + 1][j];
                
        if(x == 4 || (last == 6 && x == 2)) break; // 如果x是4或者上一位和这一位组成了62，说明这个数本身不满足要求
        last = x; // 设置last
        
        if(!i) res++; // 到了最后，说明该数本身是一种方案，累加上它
    }
    return res;
}

int main(){
    init();
    
    int l, r;
    while(cin >> l >> r, l || r) cout << dp(r) - dp(l - 1) << endl;
    
    
    return 0;
}