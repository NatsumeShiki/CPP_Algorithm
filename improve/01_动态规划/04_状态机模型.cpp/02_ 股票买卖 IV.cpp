// 给定一个长度为 N
//  的数组，数组中的第 i
//  个数字表示一个给定股票在第 i
//  天的价格。

// 设计一个算法来计算你所能获取的最大利润，你最多可以完成 k
//  笔交易。

// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。

// 输入格式
// 第一行包含整数 N
//  和 k
// ，表示数组的长度以及你可以完成的最大交易笔数。

// 第二行包含 N
//  个不超过 10000
//  的正整数，表示完整的数组。

// 输出格式
// 输出一个整数，表示最大利润。

// 数据范围
// 1≤N≤105
// ,
// 1≤k≤100
// 输入样例1：
// 3 2
// 2 4 1
// 输出样例1：
// 2
// 输入样例2：
// 6 2
// 3 2 6 5 0 3
// 输出样例2：
// 7
// 样例解释
// 样例1：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

// 样例2：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。共计利润 4+3 = 7.

/*
动态规划
  状态表示f[i, j, 0] f[i, j, 1]
    集合：
      f[i, j, 0] 从前i天中进行第j次交易，手中无股票
      f[i, j, 1] 从前i天中进行第j次交易，手中有股票
    属性：Max
  状态计算：
    手中有货 -> 手中有货 f[i - 1, j, 1]
    手中无货 -> 手中有货 f[i - 1, j - 1, 0] - w
    手中有货 -> 手中无货 f[i - 1, j, 1] + w
    手中无货 -> 手中无货 f[i - 1, j, 0]
    因此 f[i, j, 0] = max(f[i - 1, j, 1] + w, f[i - 1, j, 0]) f[i, j, 1] = max(f[i - 1, j, 1], f[i - 1, j - 1, 0] - w)

*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 110;
int f[N][M][2];

int main(){
    int n, k;
    cin >> n >> k;
    
    memset(f, -0x3f, sizeof f);
    // 从前i中选，进行第0次交易，手中不持有股票是合法的，所以设置为0，而从前i中选，进行第0次交易，手中持有股票是不合法的，题目是求最大值，所以设置为无穷小
    for(int i = 0; i <= n; i++) f[i][0][0] = 0; 
    
    for(int i = 1; i <= n; i++){
        int w;
        cin >> w;
        for(int j = 1; j <= k; j++){
            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w);
        }
    }
    
    int res = 0;
    for(int i = 0; i <= k; i++) res = max(res, f[n][i][0]); // 最终要在 从前n中选，进行第0-k次交易，手中不持有股票 取最大值
    
    cout << res << endl;
    
    return 0;
}