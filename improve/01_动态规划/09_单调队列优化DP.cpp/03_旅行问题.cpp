// John 打算驾驶一辆汽车周游一个环形公路。

// 公路上总共有 n
//  个车站，每站都有若干升汽油（有的站可能油量为零），每升油可以让汽车行驶一千米。

// John 必须从某个车站出发，一直按顺时针（或逆时针）方向走遍所有的车站，并回到起点。

// 在一开始的时候，汽车内油量为零，John 每到一个车站就把该站所有的油都带上（起点站亦是如此），行驶过程中不能出现没有油的情况。

// 任务：判断以每个车站为起点能否按条件成功周游一周。

// 输入格式
// 第一行是一个整数 n
// ，表示环形公路上的车站数；

// 接下来 n
//  行，每行两个整数 pi,di
// ，分别表示表示第 i
//  号车站的存油量和第 i
//  号车站到 顺时针方向 下一站的距离。

// 输出格式
// 输出共 n
//  行，如果从第 i
//  号车站出发，一直按顺时针（或逆时针）方向行驶，能够成功周游一圈，则在第 i
//  行输出 TAK，否则输出 NIE。

// 数据范围
// 3≤n≤106
// ,
// 0≤pi≤2×109
// ,
// 0≤di≤2×109
// 输入样例：
// 5
// 3 1
// 1 2
// 5 2
// 0 1
// 5 4
// 输出样例：
// TAK
// NIE
// TAK
// NIE
// TAK

/*
题目要求每一个点为起点能否顺时针或逆时针走一圈，所以破环成链，开二倍的空间
用o[i] - d[i]来表示从i到i+1位置获得或者消费的油，然后求前缀和
先做顺时针，开一个最长为n+1长度的单调队列，从n*2往前枚举，等到i<=n位置时，用单调队列中的最小值和s[i - 1]比较，如果最小值比他大的话，说明从i点顺时针
绕一圈到每一站都是大于等于0的，也就是说可以走完
同理再做一遍逆时针
用st来保存i点是否可以顺时针或逆时针走一圈，最后枚举这个数组一遍就可以得到答案
*/
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long ll;
const int N = 2e6 + 10; // 开二倍空间
ll s[N]; // 前缀和
int o[N], d[N]; // o是保存油量，d是保存i到i+1位置的距离
int q[N]; // 单调队列
int n;
bool st[N]; // i点是否可以顺时针或逆时针走一圈

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> o[i] >> d[i];
    
    // 顺时针
    for(int i = 1; i <= n; i++) s[i] = s[i + n] = o[i] - d[i];
    for(int i = 1; i <= n * 2; i++) s[i] += s[i - 1];
    
    int hh = 0, tt = -1;
    for(int i = n * 2; i; i--){ // 从后往前枚举
        if(hh <= tt && q[hh] > i + n) hh++; // 如果最小值的点大于i+n，不可以取这一点，所以hh往后走一步
        while(hh <= tt && s[q[tt]] >= s[i]) tt--; // 找到一个点使得s[l] <= s[i] <= s[r]
        q[++tt] = i; // 把这个点的下标插进去
        if(i <= n && s[q[hh]] >= s[i - 1]) // 只有在i<=n时才可以判断i点能否顺时针走一圈，如果单调队列的最小值比s[i-1]大，那么从i点往后走n站都是大于等于0
            st[i] = true; // 因此i点是可以顺时针走一圈的
    }
    
    // 逆时针
    d[0] = d[n]; // s[i] = o[i] - d[i - 1]，在第一站要减去d[n]，所以可以把d[0]赋值成d[n]
    for(int i = 1; i <= n; i++) s[i] = s[i + n] = o[i] - d[i - 1];
    for(int i = n * 2; i; i--) s[i] += s[i + 1]; // 反向前缀和
    
    hh = 0, tt = -1;
    for(int i = 1; i <= n * 2; i++){ // 从1开始枚举
        if(hh <= tt && q[hh] < i - n) hh++; // 如果最小值小于i-n，不可以取这一点，所以hh向后走一步
        while(hh <= tt && s[q[tt]] >= s[i]) tt--; // 找到一个点使得s[l] <= s[i] <= s[r]
        q[++tt] = i; // 把这个点的下标插进去
        if(i > n && s[q[hh]] >= s[i + 1]) // 只有在i大于n的时候才可以判断能否逆时针走一圈，如果单调队列如果单调队列的最小值比s[i+1]大，那么从i点往前走n站都是大于等于0
            st[i - n] = true; // 于是i-n这一点是可以逆时针走一圈的
    }
    
    for(int i = 1; i <= n; i++)
        if(st[i]) puts("TAK");
        else puts("NIE");
    
    return 0;
}