// 有 N
//  个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。

// 机器会把这 N
//  个任务分成若干批，每一批包含连续的若干个任务。

// 从时刻 0
//  开始，任务被分批加工，执行第 i
//  个任务所需的时间是 Ti
// 。

// 另外，在每批任务开始前，机器需要 S
//  的启动时间，故执行一批任务所需的时间是启动时间 S
//  加上每个任务所需时间之和。

// 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。

// 也就是说，同一批任务将在同一时刻完成。

// 每个任务的费用是它的完成时刻乘以一个费用系数 Ci
// 。

// 请为机器规划一个分组方案，使得总费用最小。

// 输入格式
// 第一行包含整数 N
// 。

// 第二行包含整数 S
// 。

// 接下来 N
//  行每行有一对整数，分别为 Ti
//  和 Ci
// ，表示第 i
//  个任务单独完成所需的时间 Ti
//  及其费用系数 Ci
// 。

// 输出格式
// 输出一个整数，表示最小总费用。

// 数据范围
// 1≤N≤3×105
// ,
// 1≤Ti,Ci≤512
// ,
// 0≤S≤512
// 输入样例：
// 5
// 1
// 1 3
// 3 2
// 4 3
// 2 3
// 1 4
// 输出样例：
// 153

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 300010;
int n, s;
LL c[N], t[N];
LL f[N];
int q[N];

int main(){
    cin >> n >> s;
    for(int i = 1; i <= n; i++){
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    
    int hh = 0, tt = 0;
    q[0] = 0;
    
    for(int i = 1; i <= n; i++){
        while(hh < tt && (f[q[hh + 1]] - f[q[hh]]) <= (t[i] + s) * (c[q[hh + 1]] - c[q[hh]])) hh++;
        int j = q[hh];
        f[i] = f[j] - (t[i] + s) * c[j] + t[i] * c[i] + s * c[n];
        while(hh < tt && (f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt - 1]]) >= (f[i] - f[q[tt - 1]]) * (c[q[tt]] - c[q[tt - 1]])) tt--;
        q[++tt] = i;
    }
    
    cout << f[n] << endl;
    
    return 0;
}