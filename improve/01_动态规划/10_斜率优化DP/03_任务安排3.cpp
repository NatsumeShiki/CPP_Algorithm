// 有 N
//  个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。

// 机器会把这 N
//  个任务分成若干批，每一批包含连续的若干个任务。

// 从时刻 0
//  开始，任务被分批加工，执行第 i
//  个任务所需的时间是 Ti
// 。

// 另外，在每批任务开始前，机器需要 S
//  的启动时间，故执行一批任务所需的时间是启动时间 S
//  加上每个任务所需时间之和。

// 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。

// 也就是说，同一批任务将在同一时刻完成。

// 每个任务的费用是它的完成时刻乘以一个费用系数 Ci
// 。

// 请为机器规划一个分组方案，使得总费用最小。

// 输入格式
// 第一行包含两个整数 N
//  和 S
// 。

// 接下来 N
//  行每行有一对整数，分别为 Ti
//  和 Ci
// ，表示第 i
//  个任务单独完成所需的时间 Ti
//  及其费用系数 Ci
// 。

// 输出格式
// 输出一个整数，表示最小总费用。

// 数据范围
// 1≤N≤3×105
// ,
// 0≤S,Ci≤512
// ,
// −512≤Ti≤512
// 输入样例：
// 5 1
// 1 3
// 3 2
// 4 3
// 2 3
// 1 4
// 输出样例：
// 153

/*
与上一道相比，斜率不再具有单调性，但是新加的点的横坐标一定是递增的
  在查询的时候，只能用二分来找
  在插入的时候，将队尾不再凸包上的点全部删掉
*/
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long LL;

const int N = 3e5 + 10;
LL t[N], c[N], f[N];
int q[N];
int n, s;

int main(){
    cin >> n >> s;
    for(int i = 1; i <= n; i++){
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    
    int hh = 0, tt = 0;
    q[0] = 0;
    for(int i = 1; i <= n; i++){
        int l = hh, r = tt;
        while(l < r){ // 使用二分来查找一个mid使得它的斜率比该点大
            int mid = l + r >> 1;
            if((f[q[mid + 1]] - f[q[mid]]) <= (t[i] + s) * (c[q[mid + 1]] - c[q[mid]])) l = mid + 1;
            else r = mid;
        }
        int j = q[r]; // 后面的就跟上一题一样，只是，LL可能会溢出，所以使用double来存储更大的值
        f[i] = f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]);
        while(hh < tt && (double)(f[q[tt]] - f[q[tt - 1]]) * (c[i] - c[q[tt - 1]]) >= (double)(f[i] - f[q[tt - 1]]) * (c[q[tt]] - c[q[tt - 1]])) tt--;
        q[++tt] = i;
    }
    cout << f[n] << endl;
    
    return 0;
}