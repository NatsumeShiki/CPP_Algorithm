// 将 n
//  堆石子绕圆形操场排放，现要将石子有序地合并成一堆。

// 规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。

// 请编写一个程序，读入堆数 n
//  及每堆的石子数，并进行如下计算：

// 选择一种合并石子的方案，使得做 n−1
//  次合并得分总和最大。
// 选择一种合并石子的方案，使得做 n−1
//  次合并得分总和最小。
// 输入格式
// 第一行包含整数 n
// ，表示共有 n
//  堆石子。

// 第二行包含 n
//  个整数，分别表示每堆石子的数量。

// 输出格式
// 输出共两行：

// 第一行为合并得分总和最小值，

// 第二行为合并得分总和最大值。

// 数据范围
// 1≤n≤200
// 输入样例：
// 4
// 4 5 9 4
// 输出样例：
// 43
// 54

/*
朴素的石头合并做法是先枚举长度，在枚举左端点，计算右端点，枚举中间的分割点，计算最小值或者最大值，时间复杂度是O(n ^ 3)
这道环形的有n个点，要连接n-1条边，所以最终会有一个缺口，所以朴素的做法就是枚举这个缺口，然后按照石头合并那么做，此时时间复杂度是O(n ^ 3 * n)，会TLE
优化：将数组扩大成原来的两倍，将数组向后复制一次，此时再按照石头合并那么做，时间复杂度是O(2n ^ 3)
*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 410;
int g[N][N], f[N][N], a[N]; // f[i][j]是i-j的最小值，g[i][j]是i-j的最大值
int n;

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        a[i + n] = a[i];
    }
    
    for(int i = 1; i <= 2 * n; i++) a[i] += a[i - 1]; // 求前缀和
    
    memset(f, 0x3f, sizeof f); // 计算最小值需要将它重置为最大值
    memset(g, -0x3f, sizeof g); // 计算最大值需要将它重置为最小值
    
    for(int len = 1; len <= n; len++) // 枚举长度
        for(int l = 1; l + len - 1 <= n * 2; l++){ // 枚举左端点
            int r = l + len - 1;  // 计算右端点
            if(l == r) f[l][r] = g[l][r] = 0; // 如果左右端点重合，即为0
            else{
                for(int k = l; k < r; k++){ // 否则，枚举它中间的割点
                    f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + a[r] - a[l - 1]); // 计算最小值
                    g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + a[r] - a[l - 1]); // 计算最大值
                }
            }
        }
        
    int maxv = 0, minv = 1e9; // maxv保存最终的最大值，minv保存最终的最小值
    for(int i = 1; i <= n; i++){
        minv = min(minv, f[i][i + n - 1]);
        maxv = max(maxv, g[i][i + n - 1]);
    }
    
    cout << minv << endl << maxv << endl;
    
    return 0;
}