// 为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。

// 一套防御系统的导弹拦截高度要么一直 严格单调 上升要么一直 严格单调 下降。

// 例如，一套系统先后拦截了高度为 3 和高度为 4 的两发导弹，那么接下来该系统就只能拦截高度大于 4 的导弹。

// 给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

// 输入格式
// 输入包含多组测试用例。

// 对于每个测试用例，第一行包含整数 n，表示来袭导弹数量。

// 第二行包含 n 个不同的整数，表示每个导弹的高度。

// 当输入测试用例 n=0 时，表示输入终止，且该用例无需处理。

// 输出格式
// 对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。

// 数据范围
// 1≤n≤50
// 输入样例：
// 5
// 3 5 2 4 1
// 0 
// 输出样例：
// 2
// 样例解释
// 对于给出样例，最少需要两套防御系统。

// 一套击落高度为 3,4 的导弹，另一套击落高度为 5,2,1 的导弹。

/*
在拦截导弹上使用了dfs，从原来的不下降序列变成了可以是单调上升或者单调下降序列，没有什么好的做法了，所以就使用dfs枚举每一种，枚举每一枚导弹，然后分情况，
可以把它放进上升序列中，然后向下dfs，也可以放进下降序列中，然后向下dfs，用一个全局变量来保存最小值
不适用bfs是因为它的空间是指数级别的，而且不好剪枝，在这方面不如dfs
*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 55;
int n;
int q[N], up[N], down[N]; // q保存导弹高度，up保存上升序列的最后一枚导弹高度，down保存下降序列的最后一枚导弹高度
int ans; // ans保存需要的导弹防御系统的最小值

void dfs(int u, int su, int sd){ // 第一个参数是当前枚举到第几枚导弹，su是上升系统的个数，sd是下降系统的个数
    if(su + sd >= ans) return; // 如果二者大于ans，就剪枝
    if(u == n){ // 如果到了这里并且u == n，说明ans肯定是大于su + sd的，更新ans
        ans = su + sd;
        return ;
    }
    
    int k = 0;
    while(k < su && up[k] >= q[u]) k++; // 找到上升序列中最后一枚导弹高度小于q[u]的最大值
    int t = up[k]; // 先把他保存下来
    up[k] = q[u]; // 重新赋值
    if(k < su) dfs(u + 1, su, sd); // 如果k < su，说明没有创建新的系统，向下dfs
    else dfs(u + 1, su + 1, sd);  // 创建了新的系统，所以是 su + 1
    up[k] = t; // 恢复原状
    
    k = 0;
    while(k < sd && down[k] <= q[u]) k++; // 找到下降序列中最后一枚导弹高度大于q[u]的最大值
    t = down[k]; // 先将原值保存下来
    down[k] = q[u]; // 重新赋值
    if(k < sd) dfs(u + 1, su, sd); // 如果k < sd，说明没有创建新的系统，向下dfs
    else dfs(u + 1, su, sd + 1); // 创建了新的系统，所以是 sd + 1
    down[k] = t; // 恢复原状
} 

int main(){
    while(cin >> n, n){
        for(int i = 0; i < n; i++) cin >> q[i];
        ans = n;
        dfs(0, 0, 0); 
        
        cout << ans << endl;
    }
    
    return 0;
}