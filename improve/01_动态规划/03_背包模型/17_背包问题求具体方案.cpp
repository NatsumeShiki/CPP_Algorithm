// 有 N
//  件物品和一个容量是 V
//  的背包。每件物品只能使用一次。

// 第 i
//  件物品的体积是 vi
// ，价值是 wi
// 。

// 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

// 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N
// 。

// 输入格式
// 第一行两个整数，N，V
// ，用空格隔开，分别表示物品数量和背包容积。

// 接下来有 N
//  行，每行两个整数 vi,wi
// ，用空格隔开，分别表示第 i
//  件物品的体积和价值。

// 输出格式
// 输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。

// 物品编号范围是 1…N
// 。

// 数据范围
// 0<N,V≤1000

// 0<vi,wi≤1000
// 输入样例
// 4 5
// 1 2
// 2 4
// 3 4
// 4 6
// 输出样例：
// 1 4

/*
首先要明确一点是它是不能优化成一维的，否则是无法得出具体方案的
我们可以根据二维做法倒推回去就可以得出具体方案，判断的依据就是判断每个物品是否被选
1.只能选 必选
2.只能不选 必不选
3.可选可不选 一定选（因为是要得出字典序最小的）
*/
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010;
int f[N][N], v[N], w[N];
int n, m;

int main(){
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i]; // 因为下面得出具体方案是从n - 1，所以读入数据必须在该循环中进行
    
    for(int i = n; i >= 1; i--) // 它是从后往前选的，最终f[1][m]就是最优方案
        for(int j = 0; j <= m; j++){
            f[i][j] = f[i + 1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
        }
    
    int j = m; // 最大体积是m
    for(int i = 1; i <= n; i++)
        // 如果满足了选的条件，也就是j是大于该物品的体积，并且选了给物品后使得f[i][j] == f[i + 1][j - v[i]] + w[i]，也就表示是该物品是必选
        if(j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i]){ 
            cout << i << " "; // 输出该物品
            j -= v[i]; // 体积减去该物品
        }
    
    
    return 0;
}