// Kiana 最近沉迷于一款神奇的游戏无法自拔。   

// 简单来说，这款游戏是在一个平面上进行的。 

// 有一架弹弓位于 (0,0)
//  处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟， 小鸟们的飞行轨迹均为形如 y=ax2+bx
//  的曲线，其中 a,b
//  是 Kiana 指定的参数，且必须满足 a<0
// 。

// 当小鸟落回地面（即 x
//  轴）时，它就会瞬间消失。

// 在游戏的某个关卡里，平面的第一象限中有 n
//  只绿色的小猪，其中第 i
//  只小猪所在的坐标为 (xi,yi)
// 。 

// 如果某只小鸟的飞行轨迹经过了 (xi, yi)
// ，那么第 i
//  只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 

// 如果一只小鸟的飞行轨迹没有经过 (xi, yi)
// ，那么这只小鸟飞行的全过程就不会对第 i
//  只小猪产生任何影响。 

// 例如，若两只小猪分别位于 (1,3)
//  和 (3,3)
// ，Kiana 可以选择发射一只飞行轨迹为 y=−x2+4x
//  的小鸟，这样两只小猪就会被这只小鸟一起消灭。 

// 而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。 

// 这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个这个游戏。   

// 这些指令将在输入格式中详述。 

// 假设这款游戏一共有 T
//  个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。  

// 由于她不会算，所以希望由你告诉她。

// 注意:本题除 NOIP 原数据外，还包含加强数据。

// 输入格式
// 第一行包含一个正整数 T
// ，表示游戏的关卡总数。

// 下面依次输入这 T
//  个关卡的信息。

// 每个关卡第一行包含两个非负整数 n,m
// ，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。

// 接下来的 n
//  行中，第 i
//  行包含两个正实数 (xi,yi)
// ，表示第 i
//  只小猪坐标为 (xi,yi)
// ，数据保证同一个关卡中不存在两只坐标完全相同的小猪。

// 如果 m=0
// ，表示 Kiana 输入了一个没有任何作用的指令。

// 如果 m=1
// ，则这个关卡将会满足：至多用 ⌈n/3+1⌉
//  只小鸟即可消灭所有小猪。

// 如果 m=2
// ，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 ⌊n/3⌋
//  只小猪。

// 保证 1≤n≤18，0≤m≤2，0<xi,yi<10
// ，输入中的实数均保留到小数点后两位。

// 上文中，符号 ⌈c⌉
//  和 ⌊c⌋
//  分别表示对 c
//  向上取整和向下取整，例如 ：⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3
// 。

// 输出格式
// 对每个关卡依次输出一行答案。

// 输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。

// 数据范围
// QQ截图20210311115727.png

// 输入样例：
// 2
// 2 0
// 1.00 3.00
// 3.00 3.00
// 5 2
// 1.00 5.00
// 2.00 8.00
// 3.00 9.00
// 4.00 8.00
// 5.00 5.00
// 输出样例：
// 1
// 1

#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 18, M = 1 << 18;
const double eps = 1e-8; // 误差

int n, m;
PDD q[N]; // 保存所有点
int path[N][N]; // path[i][j]:表示编号为i的小猪和编号为j的小猪所在的抛物线，变量的属性是这个抛物线可以消灭的小猪（编号）的二进制表示
int f[M]; // f[i]表示当前状态i中1所在位置编号的小猪被消灭了，所需要的最少的小鸟的数量
// 计算:找到i状态下没有被消灭的小猪的编号x，枚举可以被消灭的所有抛物线 path[x][j]更新状态 f[i | path[x][j] = min(f[i | path[x][j], f[i] + 1)

int cmp(double x, double y){ // 判断两个浮点数是否相等，误差在eps以下即为相等
    if(fabs(x - y) < eps) return 0; // 如果小于，返回0
    if(x < y) return -1; // 如果前者小于后者，返回小于0
    return 1; // 否则返回大于0
}

int main(){
    
    int t;
    cin >> t;
    while(t--){
        cin >> n >> m;
        for(int i = 0; i < n; i++) cin >> q[i].x >> q[i].y; // 保存所有点
        
        memset(path, 0, sizeof path); // 重置path
        for(int i = 0; i < n; i++){ // 枚举每一个点
            path[i][i] = 1 << i; // 设置这个表示可以消灭编号为i的小猪
            for(int j = 0; j < n; j++){ // 枚举另一只小猪的编号
                double x1 = q[i].x, y1 = q[i].y; // 或者这两只小猪的x，y坐标
                double x2 = q[j].x, y2 = q[j].y;

                if(!cmp(x1, x2)) continue; // 如果这两个小猪的x坐标相等，斜率a小于0，所以非法

                double a = (y1 / x1 - y2 / x2) / (x1 - x2); // 计算抛物线的 a 和 b
                double b = y1 / x1 - a * x1;
                
                if(cmp(a, 0) >= 0) continue; // 如果a >= 0，不合法
                int state = 0; // 定义经过i 和 j 的状态
                for(int k = 0; k < n; k++){ // 枚举所有小猪
                    double x = q[k].x, y = q[k].y; // 获取该小猪的x y 坐标
                    if(!cmp(a * x * x + b * x , y)) state += 1 << k; // 如果它在这个点上，在state的指定位置赋值1
                }
                path[i][j] = state; // 最终经过i和j两个点的状态就是state
            }
        }
        
        memset(f, 0x3f, sizeof f); // f设置为无穷大
        f[0] = 0; // 一只都没有打死设置为0
        for(int i = 0; i < 1 << n; i++){ // 枚举所有方案
            int x; // 保存第一个小猪没被打死的编号 
            for(int j = 0; j < n; j++) // 枚举所有小猪
                if(!(i >> j & 1)){ // 如果j编号小猪没被打死
                    x = j; // x赋值为该编号
                    break; // 跳出循环
                }
                
            for(int j = 0; j < n; j++) // 枚举所有点，经过编号x 和 j，获取f的较小值
                f[i | path[x][j]] = min(f[i | path[x][j]], f[i] + 1);
        }
        
        cout << f[(1 << n) - 1] << endl; // 最终输出二进制表示所有都为1的需要小鸟的数量的最小值
    }
    
    
    return 0;
}