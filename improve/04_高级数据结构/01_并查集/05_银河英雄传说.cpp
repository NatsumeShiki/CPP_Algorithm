// 有一个划分为 N
//  列的星际战场，各列依次编号为 1,2,…,N
// 。

// 有 N
//  艘战舰，也依次编号为 1,2,…,N
// ，其中第 i
//  号战舰处于第 i
//  列。

// 有 T
//  条指令，每条指令格式为以下两种之一：

// M i j，表示让第 i
//  号战舰所在列的全部战舰保持原有顺序，接在第 j
//  号战舰所在列的尾部。
// C i j，表示询问第 i
//  号战舰与第 j
//  号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。
// 现在需要你编写一个程序，处理一系列的指令。

// 输入格式
// 第一行包含整数 T
// ，表示共有 T
//  条指令。

// 接下来 T
//  行，每行一个指令，指令有两种形式：M i j 或 C i j。

// 其中 M
//  和 C
//  为大写字母表示指令类型，i
//  和 j
//  为整数，表示指令涉及的战舰编号。

// 输出格式
// 你的程序应当依次对输入的每一条指令进行分析和处理：

// 如果是 M i j 形式，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；

// 如果是 C i j 形式，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 i
//  号战舰与第 j
//  号战舰之间布置的战舰数目，如果第 i
//  号战舰与第 j
//  号战舰当前不在同一列上，则输出 ?1
// 。

// 数据范围
// N≤30000,T≤500000
// 输入样例：
// 4
// M 2 3
// C 1 2
// M 2 4
// C 4 2
// 输出样例：
// -1
// 1

// 这道题要维护两个数组，sz用于保存连通块中点的数量，d用于保存到根节点的距离
#include<iostream>
#include<cstring>
using namespace std;

const int N = 30010;
int p[N], sz[N], d[N];
int n, t;

int find(int x){
    if(x != p[x]){ 
        int t = find(p[x]); // 先查询到x的父亲节点
        d[x] += d[p[x]]; // x到祖宗节点的距离加上它的父亲到祖宗节点距离
        p[x] = t; // 然后再把x的祖宗节点设置为t
    }
    return p[x];
}

int main(){
    cin >> t;
    for(int i = 1; i < N; i++) p[i] = i, sz[i] = 1; // 初始化它的父节点和连通块中点的数量
    while(t--){
        char c;
        int a, b;
        cin >> c >> a >> b;
        int pa = find(a), pb = find(b); // 先查询a和b的祖宗节点
        if(c == 'M'){
            if(pa == pb) continue; // 如果他们已经在一个连通块中了，进行下一步
            d[pa] = sz[pb]; // 将a这一列排到b的后面，所以pa到pb的距离就是pb所在连通块中点的数量
            sz[pb] += sz[pa]; // 合并后pb连通块点的数量加上pa连通块中点的数量
            p[pa] = pb; // pa的父节点设置为pb
        }else{
            if(pa != pb) puts("-1"); // 如果不在一个连通块中，输出-1
            else cout << max(0, abs(d[b] - d[a]) - 1) << endl; // 否则输出他们之间战舰的数量，如果a和b是同一个，那么后者结果是-1，所以与0取较大值
        }
    }
    
    return 0;
}